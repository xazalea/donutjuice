/**
 * HTTP Header Manipulation Module
 * Modify HTTP headers to bypass security checks
 */

export interface HeaderVulnerability {
  header: string;
  value: string;
  issue: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
}

export class HTTPHeaderManipulator {
  /**
   * Test header injection
   */
  async testHeaderInjection(url: string, headerName: string, maliciousValue: string): Promise<HeaderVulnerability[]> {
    const vulnerabilities: HeaderVulnerability[] = [];
    
    try {
      const response = await fetch(url, {
        headers: {
          [headerName]: maliciousValue,
        },
      });
      
      // Check if header was reflected
      const responseHeaders = Array.from(response.headers.entries());
      for (const [name, value] of responseHeaders) {
        if (value.includes(maliciousValue)) {
          vulnerabilities.push({
            header: name,
            value,
            issue: 'Header value reflected in response',
            severity: 'high',
          });
        }
      }
    } catch (error) {
      console.error('Error testing header injection:', error);
    }
    
    return vulnerabilities;
  }

  /**
   * Check for security headers
   */
  async checkSecurityHeaders(url: string): Promise<HeaderVulnerability[]> {
    const vulnerabilities: HeaderVulnerability[] = [];
    const requiredHeaders = [
      'X-Content-Type-Options',
      'X-Frame-Options',
      'X-XSS-Protection',
      'Strict-Transport-Security',
      'Content-Security-Policy',
      'Referrer-Policy',
      'Permissions-Policy',
    ];
    
    try {
      const response = await fetch(url, { method: 'HEAD' });
      
      for (const header of requiredHeaders) {
        const value = response.headers.get(header);
        if (!value) {
          vulnerabilities.push({
            header,
            value: 'missing',
            issue: `Missing security header: ${header}`,
            severity: this.getHeaderSeverity(header),
          });
        } else {
          // Check for weak values
          if (this.isWeakHeaderValue(header, value)) {
            vulnerabilities.push({
              header,
              value,
              issue: `Weak ${header} value: ${value}`,
              severity: 'medium',
            });
          }
        }
      }
    } catch (error) {
      console.error('Error checking security headers:', error);
    }
    
    return vulnerabilities;
  }

  /**
   * Test for host header injection
   */
  async testHostHeaderInjection(url: string): Promise<HeaderVulnerability[]> {
    const vulnerabilities: HeaderVulnerability[] = [];
    const maliciousHosts = [
      'evil.com',
      'localhost',
      '127.0.0.1',
      '0.0.0.0',
    ];
    
    for (const maliciousHost of maliciousHosts) {
      try {
        const response = await fetch(url, {
          headers: {
            'Host': maliciousHost,
          },
        });
        
        const text = await response.text();
        if (text.includes(maliciousHost)) {
          vulnerabilities.push({
            header: 'Host',
            value: maliciousHost,
            issue: 'Host header value reflected in response',
            severity: 'high',
          });
        }
      } catch (error) {
        // Expected for some cases
      }
    }
    
    return vulnerabilities;
  }

  private getHeaderSeverity(header: string): 'low' | 'medium' | 'high' | 'critical' {
    const severityMap: Record<string, 'low' | 'medium' | 'high' | 'critical'> = {
      'Strict-Transport-Security': 'critical',
      'Content-Security-Policy': 'high',
      'X-Frame-Options': 'high',
      'X-Content-Type-Options': 'medium',
      'X-XSS-Protection': 'low',
      'Referrer-Policy': 'low',
      'Permissions-Policy': 'medium',
    };
    
    return severityMap[header] || 'medium';
  }

  private isWeakHeaderValue(header: string, value: string): boolean {
    if (header === 'X-Frame-Options' && value.toUpperCase() !== 'DENY' && value.toUpperCase() !== 'SAMEORIGIN') {
      return true;
    }
    if (header === 'X-XSS-Protection' && !value.includes('1; mode=block')) {
      return true;
    }
    if (header === 'Strict-Transport-Security' && !value.includes('max-age')) {
      return true;
    }
    return false;
  }
}

