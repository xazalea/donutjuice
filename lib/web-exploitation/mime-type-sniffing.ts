/**
 * MIME-Type Sniffing Module
 * Exploit MIME type vulnerabilities to execute arbitrary code
 */

export interface MIMETypeVulnerability {
  url: string;
  declaredType: string;
  actualType: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
}

export class MIMETypeSniffer {
  /**
   * Test for MIME type confusion
   */
  async testMIMEType(url: string): Promise<MIMETypeVulnerability[]> {
    const vulnerabilities: MIMETypeVulnerability[] = [];
    
    try {
      const response = await fetch(url, { method: 'HEAD' });
      const declaredType = response.headers.get('Content-Type') || 'unknown';
      
      // Try to load as different types
      const testTypes = ['text/html', 'application/javascript', 'text/xml', 'application/json'];
      
      for (const testType of testTypes) {
        if (this.isMIMETypeConfusion(declaredType, testType)) {
          vulnerabilities.push({
            url,
            declaredType,
            actualType: testType,
            severity: this.calculateSeverity(declaredType, testType),
            description: `MIME type confusion: declared as ${declaredType} but can be interpreted as ${testType}`,
          });
        }
      }
    } catch (error) {
      console.error('Error testing MIME type:', error);
    }
    
    return vulnerabilities;
  }

  /**
   * Test for content sniffing vulnerabilities
   */
  async testContentSniffing(url: string): Promise<MIMETypeVulnerability[]> {
    const vulnerabilities: MIMETypeVulnerability[] = [];
    
    try {
      const response = await fetch(url);
      const contentType = response.headers.get('Content-Type') || '';
      const xContentTypeOptions = response.headers.get('X-Content-Type-Options');
      
      if (!xContentTypeOptions || xContentTypeOptions.toLowerCase() !== 'nosniff') {
        vulnerabilities.push({
          url,
          declaredType: contentType,
          actualType: 'sniffed',
          severity: 'medium',
          description: 'Missing X-Content-Type-Options: nosniff header allows MIME type sniffing',
        });
      }
    } catch (error) {
      console.error('Error testing content sniffing:', error);
    }
    
    return vulnerabilities;
  }

  private isMIMETypeConfusion(declared: string, test: string): boolean {
    // Check if declared type could be confused with test type
    const declaredBase = declared.split(';')[0].trim().toLowerCase();
    const testBase = test.split(';')[0].trim().toLowerCase();
    
    // Common confusion scenarios
    if (declaredBase === 'text/plain' && testBase === 'text/html') {
      return true;
    }
    if (declaredBase === 'text/plain' && testBase === 'application/javascript') {
      return true;
    }
    if (declaredBase === 'application/octet-stream' && testBase === 'application/javascript') {
      return true;
    }
    
    return false;
  }

  private calculateSeverity(declared: string, actual: string): 'low' | 'medium' | 'high' | 'critical' {
    if (actual.includes('javascript') && !declared.includes('javascript')) {
      return 'critical';
    }
    if (actual.includes('html') && !declared.includes('html')) {
      return 'high';
    }
    return 'medium';
  }
}

