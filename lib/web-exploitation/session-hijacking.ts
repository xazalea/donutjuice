/**
 * Session Hijacking Module
 * Detect and exploit session management flaws
 */

export interface SessionVulnerability {
  type: string;
  location: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
}

export class SessionHijackingDetector {
  /**
   * Check for insecure session cookies
   */
  checkCookies(): SessionVulnerability[] {
    const vulnerabilities: SessionVulnerability[] = [];
    const cookies = document.cookie.split(';');
    
    for (const cookie of cookies) {
      const [name, value] = cookie.trim().split('=');
      
      // Check if HttpOnly flag is missing
      if (!this.hasHttpOnlyFlag(name)) {
        vulnerabilities.push({
          type: 'Missing HttpOnly flag',
          location: name,
          severity: 'medium',
          description: `Cookie ${name} is accessible via JavaScript, vulnerable to XSS`,
        });
      }
      
      // Check if Secure flag is missing
      if (!this.hasSecureFlag(name) && window.location.protocol === 'https:') {
        vulnerabilities.push({
          type: 'Missing Secure flag',
          location: name,
          severity: 'high',
          description: `Cookie ${name} can be transmitted over unencrypted connections`,
        });
      }
      
      // Check for predictable session IDs
      if (this.isSessionCookie(name) && this.isPredictable(value)) {
        vulnerabilities.push({
          type: 'Predictable session ID',
          location: name,
          severity: 'critical',
          description: `Session ID in ${name} appears to be predictable`,
        });
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Test for session fixation
   */
  async testSessionFixation(url: string): Promise<SessionVulnerability[]> {
    const vulnerabilities: SessionVulnerability[] = [];
    
    // Get initial session
    const initialSession = this.getSessionId();
    
    // Make request
    await fetch(url);
    
    // Check if session changed
    const newSession = this.getSessionId();
    
    if (initialSession === newSession) {
      vulnerabilities.push({
        type: 'Session fixation vulnerability',
        location: url,
        severity: 'high',
        description: 'Session ID does not change after authentication',
      });
    }
    
    return vulnerabilities;
  }

  /**
   * Check for session timeout issues
   */
  checkSessionTimeout(): SessionVulnerability[] {
    const vulnerabilities: SessionVulnerability[] = [];
    
    // Check if session expires properly
    const localStorage = window.localStorage;
    
    // Look for session data that should expire
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.toLowerCase().includes('session')) {
        const value = localStorage.getItem(key);
        if (value) {
          try {
            const parsed = JSON.parse(value);
            if (parsed.expires && new Date(parsed.expires) < new Date()) {
              // Session should have expired but data still exists
              vulnerabilities.push({
                type: 'Session timeout not enforced',
                location: key,
                severity: 'medium',
                description: 'Session data exists after expiration time',
              });
            }
          } catch {
            // Not JSON, check if it's old
            vulnerabilities.push({
              type: 'Potential session timeout issue',
              location: key,
              severity: 'low',
              description: 'Session data in localStorage may not expire properly',
            });
          }
        }
      }
    }
    
    return vulnerabilities;
  }

  private hasHttpOnlyFlag(_cookieName: string): boolean {
    // Note: JavaScript cannot read HttpOnly flag, so we check if cookie is accessible
    // If we can read it, HttpOnly is likely not set
    return true; // Simplified check
  }

  private hasSecureFlag(_cookieName: string): boolean {
    // Note: JavaScript cannot directly check Secure flag
    // This is a heuristic check
    return window.location.protocol === 'https:';
  }

  private isSessionCookie(name: string): boolean {
    const sessionKeywords = ['session', 'sid', 'jsessionid', 'phpsessid', 'asp.net_sessionid'];
    return sessionKeywords.some(keyword => name.toLowerCase().includes(keyword));
  }

  private isPredictable(value: string): boolean {
    // Check if value is sequential or follows a pattern
    if (/^\d+$/.test(value)) {
      return true; // Numeric only
    }
    if (value.length < 16) {
      return true; // Too short
    }
    // Check for patterns
    const uniqueChars = new Set(value).size;
    if (uniqueChars < value.length * 0.3) {
      return true; // Low entropy
    }
    return false;
  }

  private getSessionId(): string {
    const cookies = document.cookie.split(';');
    for (const cookie of cookies) {
      const [name] = cookie.trim().split('=');
      if (this.isSessionCookie(name)) {
        return cookie;
      }
    }
    return '';
  }
}

