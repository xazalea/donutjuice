/**
 * Cross-Site Scripting (XSS) Detection Module
 * Scans for XSS vulnerabilities in web applications
 */

export interface XSSVulnerability {
  type: 'reflected' | 'stored' | 'dom-based';
  location: string;
  payload: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
}

export class XSSDetector {
  private testPayloads: string[] = [
    '<script>alert("XSS")</script>',
    '<img src=x onerror=alert("XSS")>',
    '<svg onload=alert("XSS")>',
    'javascript:alert("XSS")',
    '<iframe src="javascript:alert(\'XSS\')"></iframe>',
    '<body onload=alert("XSS")>',
    '<input onfocus=alert("XSS") autofocus>',
    '<select onfocus=alert("XSS") autofocus>',
    '<textarea onfocus=alert("XSS") autofocus>',
    '<keygen onfocus=alert("XSS") autofocus>',
    '<video><source onerror="alert(\'XSS\')">',
    '<audio src=x onerror=alert("XSS")>',
  ];

  /**
   * Scan a URL for XSS vulnerabilities
   */
  async scanURL(url: string): Promise<XSSVulnerability[]> {
    const vulnerabilities: XSSVulnerability[] = [];
    
    for (const payload of this.testPayloads) {
      try {
        const testURL = this.injectPayload(url, payload);
        const response = await fetch(testURL);
        const text = await response.text();
        
        if (this.isPayloadReflected(text, payload)) {
          vulnerabilities.push({
            type: 'reflected',
            location: url,
            payload,
            severity: this.calculateSeverity(payload),
            description: `Reflected XSS vulnerability found with payload: ${payload}`,
          });
        }
      } catch (error) {
        console.error(`Error testing payload ${payload}:`, error);
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Scan DOM for XSS vulnerabilities
   */
  scanDOM(): XSSVulnerability[] {
    const vulnerabilities: XSSVulnerability[] = [];
    
    // Check for dangerous DOM operations
    const scripts = document.querySelectorAll('script');
    scripts.forEach((script, index) => {
      if (script.innerHTML.includes('eval(') || script.innerHTML.includes('innerHTML')) {
        vulnerabilities.push({
          type: 'dom-based',
          location: `script[${index}]`,
          payload: script.innerHTML,
          severity: 'high',
          description: 'Potentially dangerous DOM manipulation detected',
        });
      }
    });
    
    // Check for user-controlled sources
    const images = document.querySelectorAll('img');
    images.forEach((img, index) => {
      if (img.src && (img.src.startsWith('javascript:') || img.onerror)) {
        vulnerabilities.push({
          type: 'dom-based',
          location: `img[${index}]`,
          payload: img.outerHTML,
          severity: 'medium',
          description: 'Image with potentially dangerous attributes',
        });
      }
    });
    
    return vulnerabilities;
  }

  /**
   * Test form inputs for XSS
   */
  async testFormInputs(formSelector: string): Promise<XSSVulnerability[]> {
    const vulnerabilities: XSSVulnerability[] = [];
    const form = document.querySelector(formSelector) as HTMLFormElement;
    
    if (!form) return vulnerabilities;
    
    const inputs = form.querySelectorAll('input, textarea, select');
    
    for (const input of Array.from(inputs)) {
      for (const payload of this.testPayloads) {
        (input as HTMLInputElement).value = payload;
        
        // Check if payload is reflected in DOM
        const formData = new FormData(form);
        const reflected = Array.from(formData.values()).some(v => 
          v.toString().includes(payload)
        );
        
        if (reflected) {
          vulnerabilities.push({
            type: 'stored',
            location: input.getAttribute('name') || input.id || 'unknown',
            payload,
            severity: this.calculateSeverity(payload),
            description: `Stored XSS vulnerability in form input`,
          });
        }
      }
    }
    
    return vulnerabilities;
  }

  private injectPayload(url: string, payload: string): string {
    const urlObj = new URL(url);
    const params = new URLSearchParams(urlObj.search);
    
    // Try injecting into each parameter
    for (const key of params.keys()) {
      params.set(key, payload);
    }
    
    urlObj.search = params.toString();
    return urlObj.toString();
  }

  private isPayloadReflected(html: string, payload: string): boolean {
    // Check if payload appears in response
    return html.includes(payload) || 
           html.includes(payload.replace(/</g, '&lt;').replace(/>/g, '&gt;'));
  }

  private calculateSeverity(payload: string): 'low' | 'medium' | 'high' | 'critical' {
    if (payload.includes('eval(') || payload.includes('Function(')) {
      return 'critical';
    }
    if (payload.includes('onerror') || payload.includes('onload')) {
      return 'high';
    }
    if (payload.includes('<script>')) {
      return 'high';
    }
    return 'medium';
  }
}

