/**
 * Persistent Exploit Finder
 * NEVER FAILS - keeps trying until it finds an exploit
 * Uses SearXNG, source code search, chromebook-utilities, and AI models
 */

import { ChromeOSSourceCodeSearch, ExploitFinding } from './source-code-search';
import { SearXNGIntegration } from '@lib/integrations/searxng';
import { ModelManager } from '@lib/ai/model-manager';
import { ExploitDatabase, ExploitRecord } from '@lib/database/exploit-db';
import { ExploitPrompts } from '@lib/ai/exploit-prompts';
import { OpenReason } from '@lib/integrations/openreason';
import { OpenMemory } from '@lib/integrations/openmemory';

export interface ExploitSearchProgress {
  attempt: number;
  status: 'searching' | 'analyzing' | 'found' | 'retrying';
  currentSource: string;
  findings: ExploitFinding[];
  message: string;
}

export class PersistentExploitFinder {
  private sourceCodeSearch: ChromeOSSourceCodeSearch;
  private searxng: SearXNGIntegration;
  private modelManager: ModelManager;
  private database: ExploitDatabase;
  private reasoner: OpenReason;
  private memory: OpenMemory;
  private maxAttempts: number = 50; // Will keep trying up to 50 times
  private onProgress?: (progress: ExploitSearchProgress) => void;

  constructor(
    modelManager: ModelManager,
    onProgress?: (progress: ExploitSearchProgress) => void
  ) {
    this.modelManager = modelManager;
    this.sourceCodeSearch = new ChromeOSSourceCodeSearch(
      modelManager,
      modelManager.getBellum()
    );
    this.searxng = new SearXNGIntegration();
    this.database = new ExploitDatabase();
    this.reasoner = modelManager.getOpenReason();
    this.memory = modelManager.getOpenMemory();
    this.onProgress = onProgress;
  }

  /**
   * Find exploit - NEVER FAILS, keeps trying until success
   */
  async findExploit(userQuery: string): Promise<ExploitRecord> {
    let attempt = 0;
    let allFindings: ExploitFinding[] = [];

    while (attempt < this.maxAttempts) {
      attempt++;
      
      this.reportProgress({
        attempt,
        status: 'searching',
        currentSource: 'Starting comprehensive search...',
        findings: allFindings,
        message: `Attempt ${attempt}/${this.maxAttempts}: Searching for exploit...`,
      });

      try {
        // 1. SearXNG Web Search
        this.reportProgress({
          attempt,
          status: 'searching',
          currentSource: 'SearXNG Web Search',
          findings: allFindings,
          message: 'Searching web for ChromeOS exploits...',
        });

        const searxngResults = await this.searxng.comprehensiveExploitSearch(userQuery);
        
        // Extract potential exploits from web results
        const webFindings = await this.analyzeWebResults(searxngResults, userQuery);
        allFindings.push(...webFindings);

        // 2. ChromeOS Source Code Search - SCAN ENTIRE CODEBASE
        this.reportProgress({
          attempt,
          status: 'searching',
          currentSource: 'ChromeOS Source Code',
          findings: allFindings,
          message: 'Scanning ENTIRE ChromeOS codebase...',
        });

        // Scan the entire codebase for comprehensive context
        await this.sourceCodeSearch.scanEntireCodebase(userQuery, (progress) => {
          this.reportProgress({
            attempt,
            status: 'searching',
            currentSource: 'ChromeOS Source Code',
            findings: allFindings,
            message: progress,
          });
        });

        // Now search for exploit patterns with full codebase context
        const sourceFindings = await this.sourceCodeSearch.searchExploitPatterns(userQuery);
        allFindings.push(...sourceFindings);

        // 2b. Chromium Source Code Search
        this.reportProgress({
          attempt,
          status: 'searching',
          currentSource: 'Chromium Source Code',
          findings: allFindings,
          message: 'Searching Chromium source code repository...',
        });

        const chromiumResults = await this.sourceCodeSearch.searchChromiumSource(userQuery);
        if (chromiumResults.length > 0) {
          allFindings.push({
            name: 'Chromium Source Code Results',
            description: `Found ${chromiumResults.length} relevant locations in Chromium source`,
            severity: 'medium',
            sourceCodeResults: chromiumResults,
            exploitType: 'chromium',
            affectedComponents: ['browser', 'security', 'enrollment'],
          });
        }

        // 3. Chromebook Utilities Analysis
        this.reportProgress({
          attempt,
          status: 'searching',
          currentSource: 'Chromebook Utilities',
          findings: allFindings,
          message: 'Analyzing chromebook-utilities.pages.dev patterns...',
        });

        const utilitiesFindings = await this.analyzeChromebookUtilities(userQuery);
        allFindings.push(...utilitiesFindings);

        // 4. Store context in memory for full OS/Browser context
        this.memory.store(
          `Full ChromeOS/Chromium context for exploit search: ${userQuery}`,
          {
            query: userQuery,
            attempt,
            findings: allFindings.map(f => f.name),
            timestamp: new Date().toISOString(),
          },
          ['chromeos', 'chromium', 'full-context', 'exploit-search']
        );

        // Retrieve relevant memories for context
        const relevantMemories = this.memory.retrieve({
          query: userQuery,
          tags: ['chromeos', 'chromium', 'exploit', 'unenrollment', 'oobe'],
          limit: 50,
        });

        // Build full context from memories
        const fullContext = relevantMemories
          .map(m => m.content)
          .join('\n\n');

        // 5. AI-Powered Deep Analysis with Full Context
        this.reportProgress({
          attempt,
          status: 'analyzing',
          currentSource: 'AI Analysis (Full OS/Browser Context)',
          findings: allFindings,
          message: 'Using AI models with full ChromeOS/Chromium context...',
        });

        const aiFindings = await this.aiDeepAnalysis(userQuery, allFindings, fullContext);
        allFindings.push(...aiFindings);

        // 6. Use OpenReasoning for deep analysis
        this.reportProgress({
          attempt,
          status: 'analyzing',
          currentSource: 'OpenReasoning Analysis',
          findings: allFindings,
          message: 'Using OpenReasoning for exploit chain analysis...',
        });

        for (const finding of allFindings.slice(0, 10)) {
          try {
            const reasoning = await this.reasoner.reasonAboutUnenrollmentExploit(
              finding.name,
              {
                type: finding.exploitType,
                severity: finding.severity,
                description: finding.description,
                context: fullContext,
              }
            );
            
            // Store reasoning in memory
            this.memory.store(
              `Reasoning for ${finding.name}: ${reasoning.conclusion}`,
              {
                finding: finding.name,
                reasoning: reasoning.conclusion,
                confidence: reasoning.confidence,
                steps: reasoning.steps,
              },
              ['reasoning', finding.exploitType, finding.severity]
            );

            // If reasoning shows high confidence, enhance finding
            if (reasoning.confidence > 0.7) {
              finding.description += `\n\nReasoning: ${reasoning.conclusion}`;
            }
          } catch (error) {
            console.warn('Reasoning failed for finding:', error);
          }
        }

        // 5. Check if we found anything
        if (allFindings.length > 0) {
          // Deduplicate and prioritize
          const uniqueFindings = this.deduplicateFindings(allFindings);
          const bestFinding = this.selectBestFinding(uniqueFindings);

          if (bestFinding) {
            // Generate complete exploit guide
            this.reportProgress({
              attempt,
              status: 'found',
              currentSource: 'Exploit Found!',
              findings: [bestFinding],
              message: `Found exploit: ${bestFinding.name}`,
            });

            const exploitRecord = await this.createExploitRecord(bestFinding, userQuery);
            await this.database.saveExploit(exploitRecord);

            return exploitRecord;
          }
        }

        // 6. If no exploit found, try different search strategies
        this.reportProgress({
          attempt,
          status: 'retrying',
          currentSource: 'Trying Alternative Strategies',
          findings: allFindings,
          message: `No exploit found yet. Trying alternative search strategies...`,
        });

        // Try alternative queries
        const alternativeQueries = this.generateAlternativeQueries(userQuery, attempt);
        for (const altQuery of alternativeQueries) {
          const altFindings = await this.sourceCodeSearch.searchExploitPatterns(altQuery);
          allFindings.push(...altFindings);
        }

        // Try connecting multiple vulnerabilities
        if (allFindings.length >= 2) {
          const chainedExploit = await this.chainExploits(allFindings);
          if (chainedExploit) {
            const exploitRecord = await this.createExploitRecord(chainedExploit, userQuery);
            await this.database.saveExploit(exploitRecord);
            return exploitRecord;
          }
        }

      } catch (error) {
        console.error(`Attempt ${attempt} failed:`, error);
        // Continue to next attempt
      }

      // Small delay before next attempt
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    // If we've exhausted all attempts, create a general exploit based on findings
    if (allFindings.length > 0) {
      const bestFinding = this.selectBestFinding(allFindings);
      if (bestFinding) {
        const exploitRecord = await this.createExploitRecord(bestFinding, userQuery);
        await this.database.saveExploit(exploitRecord);
        return exploitRecord;
      }
    }

    // Last resort: create a theoretical exploit
    return this.createTheoreticalExploit(userQuery, allFindings);
  }

  /**
   * Analyze web search results for exploits
   */
  private async analyzeWebResults(
    searxngResults: any,
    query: string
  ): Promise<ExploitFinding[]> {
    const findings: ExploitFinding[] = [];

    // Analyze all result sources
    const allResults = [
      ...searxngResults.webResults,
      ...searxngResults.chromebookUtilities,
      ...searxngResults.sourceCode,
    ];

    // Use AI to extract exploit information from results
    for (const result of allResults.slice(0, 20)) {
      try {
        const analysisPrompt = `Analyze this web search result for ChromeOS exploit information:

Title: ${result.title}
URL: ${result.url}
Content: ${result.content.substring(0, 1000)}

Extract any exploit information, vulnerability details, or exploitation techniques.`;

        const aiResult = await this.modelManager.chat(
          analysisPrompt,
          ExploitPrompts.buildChromeOSExploitPrompt(query)
        );

        // Parse AI response for exploit findings
        if (aiResult.content.toLowerCase().includes('exploit') || 
            aiResult.content.toLowerCase().includes('vulnerability')) {
          findings.push({
            name: `Web Result: ${result.title}`,
            description: result.content.substring(0, 200),
            severity: this.inferSeverity(aiResult.content),
            sourceCodeResults: [{
              file: result.title,
              path: result.url,
              lineNumber: 0,
              code: result.content,
              context: result.content,
              url: result.url,
              relevance: 0.7,
            }],
            exploitType: 'web-research',
            affectedComponents: ['various'],
          });
        }
      } catch (error) {
        console.warn('Error analyzing web result:', error);
      }
    }

    return findings;
  }

  /**
   * Analyze chromebook-utilities patterns
   */
  private async analyzeChromebookUtilities(query: string): Promise<ExploitFinding[]> {
    const findings: ExploitFinding[] = [];

    try {
      const utilitiesResults = await this.searxng.searchChromebookUtilities(query);
      
      for (const result of utilitiesResults) {
        findings.push({
          name: `Chromebook Utilities: ${result.title}`,
          description: result.content,
          severity: 'high',
          sourceCodeResults: [{
            file: result.title,
            path: result.url,
            lineNumber: 0,
            code: result.content,
            context: result.content,
            url: result.url,
            relevance: 0.9,
          }],
          exploitType: 'chromebook-utilities',
          affectedComponents: ['enrollment', 'oobe', 'policy'],
        });
      }
    } catch (error) {
      console.warn('Chromebook utilities analysis failed:', error);
    }

    return findings;
  }

  /**
   * AI-powered deep analysis with full OS/Browser context
   */
  private async aiDeepAnalysis(
    query: string,
    existingFindings: ExploitFinding[],
    fullContext?: string
  ): Promise<ExploitFinding[]> {
    const findings: ExploitFinding[] = [];

    try {
      // Build comprehensive context
      const contextParts = [
        existingFindings.map(f => f.description).join('\n\n'),
        fullContext || '',
        // Add OS/Browser context
        'Full ChromeOS Operating System Context:',
        '- Kernel: Linux-based with security hardening',
        '- Browser: Chromium with enterprise policies',
        '- Enrollment: OOBE and server-side mechanisms',
        '- Security: TPM, cryptohome, verified boot',
        '- Developer Mode: Root access capabilities',
        '- Recovery Mode: Firmware-level access',
      ].filter(Boolean).join('\n\n');

      // Use dual-model analysis with infinite context
      const prompt = ExploitPrompts.buildChromeOSExploitPrompt(
        query,
        contextParts
      );

      // Use model manager with full context - no limits
      const aiResult = await this.modelManager.chat(
        `${query}\n\nFull Context:\n${contextParts}`,
        prompt
      );
      
      // Store AI analysis in memory
      this.memory.store(
        `AI Analysis for "${query}": ${aiResult.content.substring(0, 1000)}`,
        {
          query,
          model: aiResult.model,
          findingsCount: existingFindings.length,
        },
        ['ai-analysis', 'exploit', ...query.toLowerCase().split(' ').slice(0, 3)]
      );
      
      // Parse AI response for new findings
      const aiFindings = this.parseAIExploitFindings(aiResult.content, query);
      findings.push(...aiFindings);
    } catch (error) {
      console.warn('AI deep analysis failed:', error);
    }

    return findings;
  }

  /**
   * Parse AI response for exploit findings
   */
  private parseAIExploitFindings(aiContent: string, _query: string): ExploitFinding[] {
    const findings: ExploitFinding[] = [];

    // Look for exploit patterns in AI response
    const exploitPatterns = [
      /(?:exploit|vulnerability|bug)[:\s]+(.+?)(?:\n|$)/gi,
      /(?:CVE|CVE-\d{4}-\d+)[:\s]+(.+?)(?:\n|$)/gi,
      /(?:bypass|escalation|injection)[:\s]+(.+?)(?:\n|$)/gi,
    ];

    for (const pattern of exploitPatterns) {
      const matches = [...aiContent.matchAll(pattern)];
      for (const match of matches.slice(0, 5)) {
        const description = match[1]?.trim();
        if (description && description.length > 20) {
          findings.push({
            name: `AI-Identified: ${description.substring(0, 50)}`,
            description,
            severity: this.inferSeverity(description),
            sourceCodeResults: [],
            exploitType: 'ai-identified',
            affectedComponents: ['various'],
          });
        }
      }
    }

    return findings;
  }

  /**
   * Generate alternative search queries
   */
  private generateAlternativeQueries(originalQuery: string, attempt: number): string[] {
    const alternatives = [
      `${originalQuery} bypass`,
      `${originalQuery} exploit`,
      `${originalQuery} vulnerability`,
      `ChromeOS ${originalQuery}`,
      `${originalQuery} unenrollment`,
      `${originalQuery} root access`,
      `${originalQuery} privilege escalation`,
      `${originalQuery} kernel`,
      `${originalQuery} firmware`,
    ];

    return alternatives.slice(0, Math.min(3, attempt));
  }

  /**
   * Chain multiple exploits together
   */
  private async chainExploits(findings: ExploitFinding[]): Promise<ExploitFinding | null> {
    if (findings.length < 2) return null;

    try {
      const chainPrompt = `You are analyzing multiple ChromeOS vulnerabilities to create a chained exploit.

FINDINGS:
${findings.map((f, i) => `${i + 1}. ${f.name}: ${f.description}`).join('\n')}

TASK: Create a chained exploit that combines these vulnerabilities to achieve a more powerful attack.

OUTPUT: Provide a detailed chained exploit that uses multiple vulnerabilities together.`;

      const aiResult = await this.modelManager.chat(
        'Create a chained exploit',
        chainPrompt
      );

      return {
        name: `Chained Exploit: ${findings.map(f => f.name).join(' + ')}`,
        description: aiResult.content,
        severity: 'critical',
        sourceCodeResults: findings.flatMap(f => f.sourceCodeResults || []),
        exploitType: 'chained',
        affectedComponents: [...new Set(findings.flatMap(f => f.affectedComponents))],
      };
    } catch (error) {
      console.warn('Chaining exploits failed:', error);
      return null;
    }
  }

  /**
   * Create theoretical exploit as last resort
   */
  private async createTheoreticalExploit(
    query: string,
    _findings: ExploitFinding[]
  ): Promise<ExploitRecord> {
    const theoreticalPrompt = `Based on the search query "${query}" and any findings, create a theoretical ChromeOS exploit that could work.

Even if no exploit was found, create a plausible exploit based on:
1. Common ChromeOS vulnerability patterns
2. Similar exploits in other systems
3. Theoretical attack vectors

Provide a complete, detailed exploit with steps.`;

    const aiResult = await this.modelManager.chat(
      query,
      theoreticalPrompt
    );

    const theoreticalFinding: ExploitFinding = {
      name: `Theoretical Exploit: ${query}`,
      description: aiResult.content,
      severity: 'medium',
      sourceCodeResults: [],
      exploitType: 'theoretical',
      affectedComponents: ['various'],
    };

    return this.createExploitRecord(theoreticalFinding, query);
  }

  /**
   * Create exploit record from finding
   */
  private async createExploitRecord(
    finding: ExploitFinding,
    searchQuery: string
  ): Promise<ExploitRecord> {
    const guide = await this.sourceCodeSearch.generateExploitGuide(finding);

    return {
      name: finding.name,
      description: finding.description,
      severity: finding.severity,
      exploitType: finding.exploitType,
      steps: guide.steps,
      payloadCode: `# ${finding.name}\n# ${finding.description}\n\n# See steps for detailed instructions`,
      sourceCodeResults: finding.sourceCodeResults?.map(r => ({
        file: r.file,
        path: r.path,
        lineNumber: r.lineNumber,
        url: r.url,
      })),
      searchQuery,
      foundAt: new Date(),
      status: 'found',
      references: guide.references,
      reactions: {
        found: 0,
        tested: 0,
        patched: 0,
        goated: 0,
      },
    };
  }

  /**
   * Select best finding from list
   */
  private selectBestFinding(findings: ExploitFinding[]): ExploitFinding | null {
    if (findings.length === 0) return null;

    // Prioritize by severity and source code results
    const scored = findings.map(f => ({
      finding: f,
      score: this.scoreFinding(f),
    }));

    scored.sort((a, b) => b.score - a.score);
    return scored[0].finding;
  }

  /**
   * Score finding for prioritization
   */
  private scoreFinding(finding: ExploitFinding): number {
    let score = 0;

    // Severity scoring
    const severityScores = { critical: 100, high: 75, medium: 50, low: 25 };
    score += severityScores[finding.severity] || 0;

    // Source code results
    score += (finding.sourceCodeResults?.length || 0) * 10;

    // Exploit type scoring
    const typeScores: Record<string, number> = {
      'chained': 50,
      'chromebook-utilities': 40,
      'kernel': 35,
      'unenrollment': 30,
      'ai-identified': 20,
      'theoretical': 10,
    };
    score += typeScores[finding.exploitType] || 0;

    return score;
  }

  /**
   * Deduplicate findings
   */
  private deduplicateFindings(findings: ExploitFinding[]): ExploitFinding[] {
    const seen = new Set<string>();
    const unique: ExploitFinding[] = [];

    for (const finding of findings) {
      const key = `${finding.name}-${finding.exploitType}`;
      if (!seen.has(key)) {
        seen.add(key);
        unique.push(finding);
      }
    }

    return unique;
  }

  /**
   * Infer severity from text
   */
  private inferSeverity(text: string): 'low' | 'medium' | 'high' | 'critical' {
    const textLower = text.toLowerCase();
    if (textLower.includes('critical') || textLower.includes('rce') || textLower.includes('remote code')) {
      return 'critical';
    }
    if (textLower.includes('high') || textLower.includes('privilege') || textLower.includes('root')) {
      return 'high';
    }
    if (textLower.includes('medium')) {
      return 'medium';
    }
    return 'low';
  }

  /**
   * Report progress
   */
  private reportProgress(progress: ExploitSearchProgress) {
    if (this.onProgress) {
      this.onProgress(progress);
    }
  }
}

