/**
 * PostgreSQL Database Integration for Exploit Storage
 * Stores all found exploits in a persistent database
 */

export interface ExploitRecord {
  id?: number;
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  exploitType: string;
  steps: Array<{ title: string; description: string; code?: string }>;
  payloadCode?: string;
  sourceCodeResults?: Array<{
    file: string;
    path: string;
    lineNumber: number;
    url: string;
  }>;
  searchQuery: string;
  foundAt: Date;
  status: 'found' | 'verified' | 'tested';
  references?: Array<{ title: string; url: string }>;
  reactions?: {
    found: number;
    tested: number;
    patched: number;
    goated: number;
    userReaction?: 'found' | 'tested' | 'patched' | 'goated';
  };
}

export class ExploitDatabase {
  private isInitialized: boolean = false;
  // Connection string stored for potential future use with direct database connection
  private _connectionString: string;

  constructor(connectionString?: string) {
    this._connectionString = connectionString || 
      'postgresql://donutjuice_experience:156f2d62cf36b558854e72414fd376ee0a2464a4@80x--s.h.filess.io:5434/donutjuice_experience';
  }

  /**
   * Initialize database connection
   * Note: In browser environment, we'll use a backend API
   */
  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      // Check if backend API is available
      const response = await fetch('/api/db/health');
      if (response.ok) {
        this.isInitialized = true;
        return;
      }
    } catch (error) {
      console.warn('Database API not available, using localStorage fallback');
    }

    // Fallback to localStorage for development
    this.isInitialized = true;
  }

  /**
   * Save exploit to database
   */
  async saveExploit(exploit: ExploitRecord): Promise<number> {
    await this.initialize();

    try {
      // Try backend API first
      const response = await fetch('/api/db/exploits', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(exploit),
      });

      if (response.ok) {
        const data = await response.json();
        return data.id;
      }
    } catch (error) {
      console.warn('Backend API failed, using localStorage');
    }

    // Fallback to localStorage
    const exploits = this.getLocalExploits();
    const newId = exploits.length > 0 
      ? Math.max(...exploits.map(e => e.id || 0)) + 1 
      : 1;
    
    const exploitWithId = {
      ...exploit,
      id: newId,
      foundAt: new Date(),
    };

    exploits.push(exploitWithId);
    localStorage.setItem('exploits_db', JSON.stringify(exploits));
    
    return newId;
  }

  /**
   * Get all exploits
   */
  async getAllExploits(): Promise<ExploitRecord[]> {
    await this.initialize();

    try {
      const response = await fetch('/api/db/exploits');
      if (response.ok) {
        const data = await response.json();
        return data.exploits || [];
      }
    } catch (error) {
      console.warn('Backend API failed, using localStorage');
    }

    // Fallback to localStorage
    return this.getLocalExploits();
  }

  /**
   * Get exploit by ID
   */
  async getExploitById(id: number): Promise<ExploitRecord | null> {
    await this.initialize();

    try {
      const response = await fetch(`/api/db/exploits/${id}`);
      if (response.ok) {
        return await response.json();
      }
    } catch (error) {
      console.warn('Backend API failed, using localStorage');
    }

    // Fallback to localStorage
    const exploits = this.getLocalExploits();
    return exploits.find(e => e.id === id) || null;
  }

  /**
   * Search exploits
   */
  async searchExploits(query: string): Promise<ExploitRecord[]> {
    await this.initialize();

    try {
      const response = await fetch(`/api/db/exploits/search?q=${encodeURIComponent(query)}`);
      if (response.ok) {
        const data = await response.json();
        return data.exploits || [];
      }
    } catch (error) {
      console.warn('Backend API failed, using localStorage');
    }

    // Fallback to localStorage
    const exploits = this.getLocalExploits();
    const queryLower = query.toLowerCase();
    return exploits.filter(e => 
      e.name.toLowerCase().includes(queryLower) ||
      e.description.toLowerCase().includes(queryLower) ||
      e.searchQuery.toLowerCase().includes(queryLower)
    );
  }

  /**
   * Get local exploits from localStorage
   */
  private getLocalExploits(): ExploitRecord[] {
    try {
      const stored = localStorage.getItem('exploits_db');
      if (stored) {
        const exploits = JSON.parse(stored);
        // Convert date strings back to Date objects
        return exploits.map((e: any) => ({
          ...e,
          foundAt: new Date(e.foundAt),
        }));
      }
    } catch (error) {
      console.error('Error reading local exploits:', error);
    }
    return [];
  }

  /**
   * Update exploit status
   */
  async updateExploitStatus(id: number, status: ExploitRecord['status']): Promise<void> {
    await this.initialize();

    try {
      await fetch(`/api/db/exploits/${id}/status`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status }),
      });
    } catch (error) {
      // Fallback to localStorage
      const exploits = this.getLocalExploits();
      const exploit = exploits.find(e => e.id === id);
      if (exploit) {
        exploit.status = status;
        localStorage.setItem('exploits_db', JSON.stringify(exploits));
      }
    }
  }

  /**
   * Add reaction to exploit
   */
  async addReaction(id: number, reaction: 'found' | 'tested' | 'patched' | 'goated'): Promise<void> {
    await this.initialize();

    // Check if user already has a goated reaction
    if (reaction === 'goated') {
      const exploits = await this.getAllExploits();
      const hasGoated = exploits.some(e => e.reactions?.userReaction === 'goated');
      if (hasGoated) {
        throw new Error('You can only have one goated exploit');
      }
    }

    try {
      await fetch(`/api/db/exploits/${id}/reaction`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ reaction }),
      });
    } catch (error) {
      // Fallback to localStorage
      const exploits = this.getLocalExploits();
      const exploit = exploits.find(e => e.id === id);
      if (exploit) {
        if (!exploit.reactions) {
          exploit.reactions = { found: 0, tested: 0, patched: 0, goated: 0 };
        }
        
        // Remove previous user reaction if exists
        if (exploit.reactions.userReaction) {
          const prevReaction = exploit.reactions.userReaction;
          if (exploit.reactions[prevReaction] > 0) {
            exploit.reactions[prevReaction]--;
          }
        }
        
        // Add new reaction
        exploit.reactions[reaction] = (exploit.reactions[reaction] || 0) + 1;
        exploit.reactions.userReaction = reaction;
        
        localStorage.setItem('exploits_db', JSON.stringify(exploits));
      }
    }
  }

  /**
   * Remove user reaction
   */
  async removeReaction(id: number): Promise<void> {
    await this.initialize();

    try {
      await fetch(`/api/db/exploits/${id}/reaction`, {
        method: 'DELETE',
      });
    } catch (error) {
      // Fallback to localStorage
      const exploits = this.getLocalExploits();
      const exploit = exploits.find(e => e.id === id);
      if (exploit && exploit.reactions?.userReaction) {
        const reaction = exploit.reactions.userReaction;
        if (exploit.reactions[reaction] > 0) {
          exploit.reactions[reaction]--;
        }
        delete exploit.reactions.userReaction;
        localStorage.setItem('exploits_db', JSON.stringify(exploits));
      }
    }
  }
}

